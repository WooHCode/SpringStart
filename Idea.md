<h3> 1. DI(Dependency Injection) : 의존성주입
---
new 키워드를 사용하지 않고 스프링 컨테이너에 해당 클래스를 보유

**다섯가지의 컨테이너 생성규칙**

    1. 인터페이스를 이용하여 의존성을 만든다.
    2. 인스턴스를 명시적으로 생성하지 않는다.
    3. 어노테이션을 클래스에 부여한다.
    4. 스프링 프레임워크에서 인스턴스를 생성한다.
    5. 인스턴스를 이용하고 싶은 곳에 어노테이션을 부여한다.

**규칙 설명**
1. 인터페이스를 이용하여 의존성을 만든다.
    - 의존하는 부분에 인터페이스를 이용
2. 인스턴스를 명시적으로 생성하지 않는다.
    - 인스턴스 생성에 new 키워드를 사용하지 않는다는 것을 의미한다.
3. '어노테이션을 클래스에 부여한다'와 '스프링 프레임워크에서 인스턴스를 생성한다'
    - 인스턴스를 생성하려는 클래스에 인스턴스 생성 어노테이션을 부여한다. {@}를 붙여 사용
    - 스프링프레임워크는 시작 시 대상 프로젝트의 모든 패키지를 스캔한다. 이를 <u>'컴포넌트 스캔'</u>
   이라고 한다.
    - 인스턴스 생성의 어노테이션

| 어노테이션        | 사용상황                                   |
|--------------|----------------------------------------|
 | @Controller  | 인스턴스 생성 지시, 스프링 MVC를 이용할 때 컨트롤러에 부여    |
 | @Service     | 인스턴스 생성 지시, 트랜잭션 경계가 되는 도메인(서비스)기능에 부여 |
 | @Repository  | 인스턴스 생성 지시, 데이터베이스 액세스(리포지토리) 기능에 부여   |
 | @Component   | 위 용도 이외의 클래스에 부여                       |

4. 인스턴스를 이용하고 싶은 곳에 어노테이션을 부여한다.
    - 스프링 프레임워크에 의해 생성된 인스턴스를 이용하는 클래스에 참조를 받는 필드를 선언하고 필드에 @Autowired 어노테이션을 부여한다.

---

<h3> 2. AOP(Aspect Oriented Programming) : 관점지향 프로그래밍
---
** DB 액세스 처리에는 예외 발생 시 처리하는 내용이 반드시 포함되어야 한다.**

| 용어                | 내용                                                                              |
|-------------------|---------------------------------------------------------------------------------|
| 어드바이스(Advice)     | 횡단적 관심사의 구현(메서드), 로그 출력 및 트랜잭션 제어 등                                             |
 | 애스팩트(Aspect)      | 어드바이스를 정리한 것(클래스)                                                               |
 | 조인포인트(JoinPoint)  | 어드바이스를 중심적인 관심사(액세스 처리)에 적용하는 타이밍, 메서드(생성자) 실행 전, 메서드 실행 후 등 실행되는 타이밍           |
 | 포인트컷(Pointcut)    | 어드바이스를 삽입할 수 있는 위치, 예를들어, 메서드 이름이 get으로 시작할 때만 처리하는 조건을 정의 가능                   |
 | 인터셉터(Interceptor) | 처리의 제어를 인터셉트하기 위한 구조 또는 프로그램, 스프링 에서는 인터셉트라는 매커니즘으로 어드바이스를 중심 관심사에 추가한 것처럼 보이게함 |
 | 타겟(Target)        | 어드바이스가 도입되는 대상을 말함                                                              |

* AOP를 사용하면 클래스에서 타깃 클래스의 메서드(중심적 관심사)를 호출하는 것 처럼 보이지만, 내부적으로는 AOP 프록시(스프링이 자동 생성)가 처리를 인터셉트하고 메서드 및 어드바이스의 호출을 제어한다.

#### 어드바이스의 종류
| 어드바이스                  | 내용                                                        | 어노테이션            |
|------------------------|-----------------------------------------------------------|------------------|
| Before Advice          | 중심적 관심사가 실행되기 '이전'의 횡단적 관심사를 실행                           | @Before          |
| After Returning Advice | 중심적 관심사가 '정상적으로 종료된 후'에 횡단적 관심사를 실행                       | @AfterReturning  |
| After Throwing Advice  | 중심적 관심사로 부터 '예외가 던져진 후'로 횡단적 관심사를 실행                      | @AfterThrowing   |
| After Advice           | 중심적 관심사의 '실행 후'에 횡단적 관심사를 실행(정상 종료나 예외 종료 등의 결과와 상관없이 실행) | @After           |
| Around Advice          | 중심적 관심사 호출 전후에 횡단적 관심사를 실행                                | @Around          |
---
### AOP의 주요사항
* AOP에서는 프로그램을 2개의 요소인 중심적 관심사와 횡단적 관심사로 구성되어 있음
* 중심적 관심사는 구현해야 할 기능을 나타내는 비즈니스 로직
* 횡단적 관심사는 본질적인 기능은 아니지만 품질이나 유지보수 등의 관점에서 꼭 필요한 기능을 나타내는 프로그램
* AOP에서는 횡단적 관심사를 분리함으로써 기존 코드를 수정하지 않아고 프로그램 중에 특정 기능(공통 처리)을 추가할 수 있음
* 스프링에서는 다양한 공통 기능을 AOP에서 제공함

### ○ 메타 어노테이션 ○
 ※ 커스텀 어노테이션을 만들 때 사용하는 특수 어노테이션

1. @Target
 - 커스텀 어노테이션이 무엇을 대상으로 하고 있는지 선언하기 위해 사용
 - 어노테이션을 클래스에 부여할지, 메서드에 부여할지, 변수에 부여할지 등을 결정
 - 어노테이션을 부여할 장소는 상수(constant)로 지정함

 - 어노테이션을 추가할 수 있는 대상

| ElementType 요소              | 추가할 대상                     |
|-----------------------------|----------------------------|
| ElementType.ANNOTATION_TYPE | 어노테이션                      |
| ElementType.CONSTRUCTOR     | 생성자                        |
| ElementType.FIELD           | 필드                         |
| ElementType.METHOD          | 메서드                        |
| ElementType.PACKAGE         | 패키지                        |
| ElementType.PARAMETER       | 인수                         |
| ElementType.TYPE            | 클래스, 인터페이스(어노테이션, enum 포함) |

2. @Retention
- 컴파일할 때나 프로그램을 실행할 때 어노테이션의 정보를 보관 및 유지하는 유효 범위를 결정하기 위해 사용
- @Retention은 유효 범위별로 세 개의 상수를 제공

| 상수      | 내용                                 |
|---------|------------------------------------|
| SOURCE  | 소스가 유효범위. 컴파일할 때 어노테이션 정보가 삭제됨     |
| CLASS   | 클래스 파일은 유효하지만 JVM에서 읽어들이지 않음(기본값)  |
| RUNTIME | 실행 중일 때 JVM에서 참조할 수 있는 가장 넓은 유효 범위 |

3. @Documented
- 지정된 어노테이션을 Javadoc API 문서를 출력할 때 표시됨

4. @Inherited
- 지정한 어노테이션을 부여한 클래스를 상속하면 하위 클래스도 그 어노테이션을 부여한 것으로 설정

---

<h3> 3. 스프링 MVC(Model, View, Controller)</h3>

- 스프링 MVC란 웹 애플리케이션을 간단하게 만들 수 있는 기능을 제공하는 프레임워크
- 요청을 프런트 컨트롤러가 받아 담당하는 컨트롤러에 할당하고 처리된 데이터를 뷰로 전달
- 주요기능으로는 화면전환이나 사용자가 사용하는 브라우저와 서버 간 입출력 데이터 전달을 단순화 등
- 주요 구성요소

| 객체                | 기능 개요                                                                        |
|-------------------|------------------------------------------------------------------------------|
| DispatcherServlet | 모든 요청을 수신하는 프런트 컨트롤러                                                         |
| Model             | 컨트롤러에서 뷰에 넘겨주는 표시용 데이터 등을 저장하는 객체, HttpServletRequest나 HttpSession과 같은 기능 제공 |
| Controller        | 요청에 대응해서 처리할 내용이 있는 곳                                                        |
| Service 처리        | 데이터베이스에 접속해서 데이터를 취득하거나 데이터를 가공하는 등 여러가지 작업을 실행, 개발자가 설계하고 구현(스프링mvc와는 관계없음) |
| View              | 화면 표시 처리를 함(구체적으로는 JSP등의 처리                                                  |

- 스프링 MVC에서 요청을 받아 응답을 보낼 때 까지의 흐름
 1. 모든 요청을 수신하는 프런트 컨트롤러(DispatcherServlet)이 클라이언트로부터 요청을 수신
 2. DispatcherServlet이 컨트롤러의 요청 핸들러 메서드를 호출
 3. 컨트롤러는 비즈니스 로직 처리를 호출, 처리결과를 받음
 4. 처리 결과를 모델로 설정하고, 뷰 이름을 반환
 5. 반환된 뷰 이름을 받아 DispatcherServlet이 뷰 이름에 대응하는 뷰에 대해 화면 표시 처리를 의뢰
 6. 클라이언트가 응답을 받아 화면에 표시

- 어노테이션 정리
 1. @RequestMapping
 2. @GetMapping - CRUD에서 Read역할
 3. @PostMapping - CRUD에서 Update역할

- Thymeleaf의 특징
 1. HTML 기반의 템플릿, 정해진 문법으로 작성하면 페이지를 동적으로 조립해줌(조건 분기나 반복문을 사용가능)
 2. HTML 기반이기 때문에 최종 출력을 생각하면서 뷰를 만들 수 있음. 디자이너와 쉽게 분업가능

### * Model interface

- 처리한 데이터를 뷰에 표시하고 싶을 경우 데이터를 전달하는 역할을 함
- 스프링 MVC에 의해 관리되며, 수동 또는 자동으로 객체를 저장하고 관리하는 기능을 제공
- Model을 이용하고 싶은 경우 요청 핸들러 메서드의 인수에 Model 타입을 전달함, 스프링MVC가 자동으로 Model 타입의 인스턴스를 설정

#### * 기억해야 할 메서드 - addAttribute, 특정 이름에 대해 값을 설정
- ex) Model addAttribute(String name, Object value)

----

<h3> 4. 요청 파라미터(Request Parameter)</h3>

- 서버에 전송되는 값

| 요청 파라미터                                                           | 내용                                                            |
|-------------------------------------------------------------------|---------------------------------------------------------------|
| 요청 쿼리 스트링(query string)으로 보내지는 값 <br> ※HTTP 메서드: GET으로 서버로 데이터 전송 | 뷰에서 입력값 및 선택한 값이나 숨김 파라미터(hidden parameter)등에서 미리 뷰에 입력해둔 값 등 |
| 요청 본문(body)에 저장되어 보내지는 값 <br> ※HTTP 메서드: POST로 서버로 데이터 전송         |뷰에서 입력값 및 선택한 값이나 숨김 파라미터(hidden parameter)등에서 미리 뷰에 입력해둔 값 등|
| 뷰에서 클릭한 버튼의 name 속성값                                              | 하나의 뷰에 버튼이 여러 개 있을 때 어느 버튼인지 판별할 수 있는 값                       |
| URL경로(path)의 일부로 보내지는 값                                           | 링크 등으로 URL의 일부로 보내지는 값                                        |
 
- 요청 파라미터 취득 방법
1. @RequestParam 사용 : @RequestParam 어노테이션을 이용해 파라미터를 하나씩 취득
2. Form 클래스 사용(Form 클래스는 따로 만들어야 함) : 스프링 MVC가 Form 클래스 내의 필드에 대해 값을 저장함. 요청 파라미터를 모아서 하나의 객체로 받아들이기 때문에 자주 사용됨. 받을 때는 '형변환'이나 '포맷 지정'이 가능함.

---

<h3> 5. 유효성 검사 </h3>

- 입력 내용이 요건에 만족하는지 그 타당성을 확인하는 입력 체크를 의미함
- 크게 두가지로 나뉨
1. 단일항목검사
2. 상관항목검사(서로 관련이 있는 항목을 함께 체크하는 방법)

##### 1. 단일항목검사

- 입력 항목 하나에 설정하는 입력 체크 기능
- 필드에 어노테이션을 부여해서 사용
- 입력 체크를 위한 어노테이션은 Java EE에서 제공하는 것과 Hibernate에서 제공하는 것이 있음

| 어노테이션                | 기능 설명                                      | 사용 예                                                                                                 |
|----------------------|--------------------------------------------|------------------------------------------------------------------------------------------------------|
| @NotNull             | null값이 아닌것을 검증                             | @NotNull<br>Integer no;                                                                              |
| @NotEmpty            | 문자열이 null 혹은 공백문자("")가 아닌 것을 검증            | @NotEmpty<br>String name;                                                                            |
| @NotBlank            | 문자열이 null 혹은 공백(스페이스나 탭 등)이 아닌 것을 검증       | @NotBlank<br>String name;                                                                            |
| @Max                 | 지정한 숫자 이하인 것을 검증                           | #100이하인 것을 검증<br> @Max(100)<br>Integer price;                                                        |
| @Min                 | 지정한 숫자 이상인 것을 검증                           | #10이상인 것을 검증<br> @Min(10)<br>Integer age;                                                            |
| @Size                | 문자열이나 컬렉션(Collection)이 지정한 범위의 크기 내인 것을 검증 | #요소의 수가 0에서 10의 범위인 것을 검증(문자열은 문자열 길이, 컬렉션은 사이즈)<br>@Size(min=0,max=10)<br>List<Integer> selected;   |
| @AssetTrue           | 값이 true인 것을 검증                             | @AssertTrue<br>Boolean empty;                                                                        |
| @AssetFalse          | 값이 false인 것을 검증                            | @AssertFalse<br>Boolean empty;                                                                       |
| @Pattern             | 지정한 정규 표현과 일치하는 것을 검증                      | #영숫자 검증<br>@Pattern(regexp="[a-zA-Z0-9]*")                                                           |
| @Range               | 지정한 숫자 범위 안에 있는 것을 검증                      | #1이상, 10 이하인 것을 검증<br> @Range(min=1,max=10)<br>Integer point;                                        |
| @DecimalMax          | 지정한 숫자 이하인 것을 검증                           | #100.0 이하 검증(소수점 이하를 포함해서 검증할 때는 Max가 아니고 DecimalMax를 사용)<br>@DecimalMax("100.0")<br>BigDecimal val; |
| @DecimalMin          | 지정한 숫자 이상인 것을 검증                           | #10.0 이상 검증(소수점 이하를 포함해서 검증할 때는 Min이 아니고 DecimalMin를 사용)<br>@DecimalMin("10.0")<br>BigDecimal val;   |
| @Digits              | 정수부와 소수부의 자릿수를 검증                          | #정수부가 3, 소수부가 1인 것을 검증<br>@Digits(integer=3,fraction=1)<br>BigDecimal val;                           |
| @Future              | 미래의 날짜인 것을 검증                              | @Future<br>Date date;                                                                                |
| @Past                | 과거의 날짜인 것을 검증                              | @Past<br>Date date;                                                                                  |
| @Valid               | 중첩된 Form을 검증                               | @Valid<br>SampleForm sampleForm;                                                                     |
| @Length              | 문자열 길이가지정한 범위 안에 있는 것을 검증(문자열 전용 Size)     | @Length(min=0,max=0)<br>String name;                                                                 |
| @Email               | 문자열이 이메일 주소 형식인지 검증                        | @Email<br>String email;                                                                              |
| @CreditCardNumber    | 문자열이 신용카드 번호 형식인지 검증                       | @CreditCardNumber<br>String card;                                                                    |
| @URL                 | 문자열이 URL 형식인지 검증                           | @URL<br>String url;                                                                                  |

- 커스텀 유효성 검사
- 방법 : Bean Validation을 사용하는 방법, 스프링에서 제공하는 Validator 인터페이스를 구현하는 방법
    
*** 트랜잭션이란 : 복수의 처리를 하나의 그룹으로 묶은 것, 결과는 성공 혹은 실패만 가능, 처리 중 실패했을 경우는 실행 전의 상태로 돌아감(Rollback), 성공은 commit, 부분 성공이나 부분실패는 없음
*** form-backing bean은 html 태그의 form 태그에 직접적으로 바인딩 되며 단일 항목 유효성 검사를 위해 사용된다.    
